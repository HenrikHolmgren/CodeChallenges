#!markdown

# Common functions

So far, only contains what is expected to be a heavily reused load-and-parse method.

#!csharp

public T[] LoadAndParse<T>(string path, Func<string, T> parse = null) {  
    parse = parse ?? (p => (T) Convert.ChangeType(p, typeof(T)));
    var rawInput = System.IO.File.ReadAllLines(path);
    return rawInput
    .Where(p=>!string.IsNullOrWhiteSpace(p))
    .Select(parse)
    .ToArray();
}

#!markdown

# Day 1 - Sonar Sweep

Fairly straightforward implementation of moving sum, with the Part 1 puzzle being the special case of a moving average of 1 item.

Solution is strictly O(n)

The solution below leverages the fact that the window can be advanced with minimum calculations by subtracting the first item of the old window (which is about to exit the window) followed by adding the new element about to be added to the window. 

In this way, we can maintain a window of arbitrary size with just one addition and one subtraction pr. element.

#!csharp

{
    var input = LoadAndParse<int>(@"day1_input.txt");
    
    Console.WriteLine($"Part 1: {CountIncrements(MovingSums(input, 1))}");
    Console.WriteLine($"Part 2: {CountIncrements(MovingSums(input, 3))}");    

    int CountIncrements(IEnumerable<int> source)
        => source.Zip(source.Skip(1)).Count(p=>p.Item1 < p.Item2);

    IEnumerable<int> MovingSums(IEnumerable<int> source, int windowSize) {
        var initial = source.Take(windowSize).Sum();
        yield return initial;

        //Start a double iterator on the source collection, separated by windowSize elements
        foreach (var pair in source.Zip(source.Skip(windowSize))){

            //When advancing the window, remove the start element of the old window, and add the last element of the new window
            initial -= pair.Item1; 
            initial += pair.Item2;
            yield return initial;
        }
    }
}

#!markdown

# Day 2: Dive!

#!csharp

enum CommandDirection{ forward, down, up }
record Command (CommandDirection Direction, int Amount );
record Position(int Horizontal, int Depth);
record PositionWithAim(int Horizontal, int Depth, int Aim);

{
    var input =  LoadAndParse<Command>(@"day2_input.txt", p=>{
        var particles = p.Split(" ");
        var direction = Enum.Parse<CommandDirection>(particles[0]);
        var amount = Int32.Parse(particles[1]);
        return new Command(direction, amount);
    });

    var part1position =new Position(0,0);

    foreach(var command in input){
        part1position = command.Direction switch {
            CommandDirection.forward => part1position with {Horizontal = part1position.Horizontal + command.Amount },
            CommandDirection.down => part1position with {Depth = part1position.Depth + command.Amount },
            CommandDirection.up => part1position with {Depth = part1position.Depth - command.Amount },
            _=>part1position
        };
    }
    
    var part2position = new PositionWithAim(0,0,0);
    foreach(var command in input){
        part2position = command.Direction switch {
            CommandDirection.forward => part2position with {Horizontal = part2position.Horizontal + command.Amount, Depth = part2position.Depth + part2position.Aim * command.Amount},
            CommandDirection.down => part2position with {Aim = part2position.Aim + command.Amount },
            CommandDirection.up => part2position with {Aim = part2position.Aim - command.Amount },
            _=>part2position
        };
    }
    
    Console.WriteLine($"Part 1: {part1position.Horizontal * part1position.Depth} ({part1position})");
    Console.WriteLine($"Part 2: {part2position.Horizontal * part2position.Depth} ({part2position})");
}

#!csharp

{
    var input = LoadAndParse<string>(@"day3_test.txt");
    var bitmask = (1<<input[0].Length)-1; 
    int gamma = 0;

    for(int i = 0; i < input[0].Length; i++){
        gamma <<= 1;
        if(input.Count(p=>p[i]=='1') > input.Length/2)
            gamma++;
    }

    var epsilon = ~gamma & bitmask;

    Console.WriteLine($"Gamma: {gamma}");
    Console.WriteLine($"Epsilon: {epsilon}");
    Console.WriteLine(gamma * epsilon);

    string Reduce(IEnumerable<string> source)
    {
        for(int i = 0; i < source.First().Length; i++){            
            if(source.Count(p=>p[i]=='1') > input.Length/2)
                source = source.Where(p=>p[i] == '1');
            else 
                source = source.Where(p=>p[i]=='0');
        }
        
        return source.Sigle();
    }
}
